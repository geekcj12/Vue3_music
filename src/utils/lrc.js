/*
[00:00.000]作词 : 内澤崇仁
[00:00.850]作曲 : 内澤崇仁
[00:01.700]例えば君の顔に昔よりシワが増えても (尽管你的脸庞不如往昔那样平滑)
[00:08.700]それでもいいんだ (那也没关系)
[00:10.700]僕がギターを思うように弾けなくなっても (即使我不能如同想象中那样弹着吉他)
[00:15.700]心の歌は君で溢れているよ (心中仍唱着关于你的歌)
[00:19.700]高い声も出せずに思い通り歌えない (即使不能自如地唱出高音)
*/

// "[00:00.000]作词 : 内澤崇仁\n[00:00.850]作曲 : 内澤崇仁\n[00:01.700]例えば君の顔に昔よりシワが増えても (尽管你的脸庞不如往昔那样平滑)\n[00:08.700]それでもいいんだ (那也没关系)\n[00:10.700]僕がギターを思うように弾けなくなっても (即使我不能如同想象中那样弹着吉他)\n[00:15.700]心の歌は君で溢れているよ (心中仍唱着关于你的歌)\n[00:19.700]高い声も出せずに思い通り歌えない (即使不能自如地唱出高音)\n[00:25.250]それでもうなずきながら一緒に歌ってくれるかな (尽管如此我也希望与你一起一边轻点着头一边轻哼着歌)\n[00:30.250]割れんばかりの拍手も 響き渡る歓声もいらない (不需要热烈雷动的掌声 也不需要响彻会场的欢呼)\n[00:35.250]君だけ 分かってよ 分かってよ (只想让你明白 让你明白)\n[00:40.250]Darling 夢が叶ったの (darling 你的梦想已经实现了吧)\n[00:45.250]お似合いの言葉が見つからないよ (我却寻找不到合适的言语来祝福)\n[00:50.360]Darling 夢が叶ったの (darling 你的梦想已经实现了吧)\n[00:54.700]「愛してる」 (“我爱你”)\n[00:57.700]たった一度の たった一人の (人生只有一次的 只对一个人的)\n[01:02.250]生まれてきた幸せ味わってるんだよ (我已经尝到了活在这个世界上的幸福)\n[01:07.700]今日がメインディッシュで (今天是主菜)\n[01:09.700]終わりの日には甘酸っぱいデザートを食べるの (终结的日子是酸甜的甜品)\n[01:13.700]山も谷も全部フルコースで (无论是高峰还是低谷 都会得到的套餐)\n[01:17.250]気が利くような言葉はいらない (不需要精细周到的情话)\n[01:20.250]素晴らしい特別もいらない (也不需要完美的惊喜)\n[01:22.700]ただずっと ずっと側に置いていてよ (只希望你能一直在我身边)\n[01:27.569]僕の想いは歳をとると増えてくばっかだ 好きだよ (这份心情只会随着年岁增长而慢慢累积 我喜欢你)\n[01:33.250]分かってよ 分かってよ (你知道的 你知道的吧)\n[01:36.700]ねえ、Darling 夢が叶ったの (呐 darling 你的梦想已经实现了吧)\n[01:41.700]お似合いの言葉が見つからないよ (我却寻找不到合适的言语来祝福)\n[01:47.250]Darling 夢が叶ったの (darling 你的梦想已经实现了吧)\n[01:51.700]愛が溢れていく (对你的爱已满溢而出)\n[02:19.250]君が僕を忘れてしまっても ちょっと辛いけど… (即使你已经把我忘记 即使有些难过)\n[02:26.699]それでもいいから (那也没关系)\n[02:29.250]僕より先に どこか遠くに (但若你先离我而去)\n[02:34.030]旅立つことは 絶対 許さないから (踏上去往远方的旅程什么的 是绝对不能原谅的哟)\n[02:38.699]生まれ変わったとしても 出会い方が最悪でも (即使还有来世 即使与你相遇的方式是最差劲的)\n[02:44.250]また僕は君に恋するんだよ (我还是会再爱上你)\n[02:49.250]僕の心は君にいつも片想い 好きだよ (我一直都是单恋着你 喜欢你)\n[02:54.699]分かってよ 分かってよ 分かってよ (你是明白的 你是明白的吧)\n[03:01.250]Darling 夢が叶ったの (darling 你的梦想已经实现了吧)\n[03:06.250]お似合いの言葉が見つからないよ (我却寻找不到合适的言语来祝福)\n[03:11.250]Darling 夢が叶ったの (darling 你的梦想已经实现了吧)\n[03:16.250]ねえ Darling「愛してる」 (呐 darling “我爱你”)\n"

export const parse = (lrc_s) => {
  if (lrc_s) {
    lrc_s = lrc_s.replace(/([^\]^\n])\[/g, (match, p1) => p1 + '\n[');
    const lyric = lrc_s.split('\n');
    let lrc = [];
    const lyricLen = lyric.length;
    for (let i = 0; i < lyricLen; i++) {
      // match lrc time
      const lrcTimes = lyric[i].match(/\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g);
      // match lrc text
      const lrcText = lyric[i]
        .replace(/.*\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g, '')
        .replace(/<(\d{2}):(\d{2})(\.(\d{2,3}))?>/g, '')
        .replace(/^\s+|\s+$/g, '');

      if (lrcTimes) {
        // handle multiple time tag
        const timeLen = lrcTimes.length;
        for (let j = 0; j < timeLen; j++) {
          const oneTime = /\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/.exec(lrcTimes[j]);
          const min2sec = oneTime[1] * 60;
          const sec2sec = parseInt(oneTime[2]);
          const msec2sec = oneTime[4] ? parseInt(oneTime[4]) / ((oneTime[4] + '').length === 2 ? 100 : 1000) : 0;
          const lrcTime = min2sec + sec2sec + msec2sec;
          lrc.push([lrcTime, lrcText]);
        }
      }
    }
    // sort by time
    lrc = lrc.filter((item) => item[1]);
    lrc.sort((a, b) => a[0] - b[0]);
    return lrc;
  } else {
    return [];
  }
};
